<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="script-src 'self' 'unsafe-inline';">
</head>
<body>
  <canvas id="canvas"></canvas>
  <script>
    // IMMEDIATE TEST - this should execute as soon as script tag is parsed
    (function immediateTest() {
      try {
        // Mark that script executed
        const canvas = document.getElementById('canvas');
        if (canvas) {
          canvas.setAttribute('data-script-executed', 'true');
          canvas.setAttribute('data-script-timestamp', Date.now().toString());
        }
        
        // Try to log via IPC directly (if preload is loaded)
        if (typeof window !== 'undefined' && window.captureAPI && window.captureAPI.log) {
          window.captureAPI.log('SCRIPT TAG PARSED - IMMEDIATE', { 
            timestamp: Date.now(),
            hasWindow: typeof window !== 'undefined',
            hasDocument: typeof document !== 'undefined',
            hasCaptureAPI: typeof window.captureAPI !== 'undefined'
          });
        } else {
          // Log to console as fallback
          console.error('[CaptureFrame] Script executing but captureAPI not yet available');
        }
      } catch (e) {
        console.error('[CaptureFrame] Immediate test error:', e);
      }
    })();
    
    // Force immediate execution - don't wait for anything
    (async function captureScreen() {
      // Log immediately using any available method
      const logMsg = (msg, data) => {
        if (window.captureAPI && window.captureAPI.log) {
          window.captureAPI.log(msg, data);
        }
      };
      
      logMsg('SCRIPT EXECUTING - START', { 
        timestamp: Date.now(),
        hasWindow: typeof window !== 'undefined',
        hasDocument: typeof document !== 'undefined' 
      });
      
      try {
        // Wait for window.captureAPI (preload should have loaded it)
        logMsg('Waiting for captureAPI...');
        let retries = 0;
        while (!window.captureAPI && retries < 50) {
          await new Promise(resolve => setTimeout(resolve, 100));
          retries++;
          if (retries % 10 === 0) {
            logMsg(`Still waiting, retry ${retries}/50`);
          }
        }
        
        logMsg('Finished waiting', { hasCaptureAPI: !!window.captureAPI, retries });
        
        if (!window.captureAPI) {
          logMsg('ERROR: captureAPI not available');
          throw new Error('window.captureAPI not available after waiting');
        }
        
        logMsg('Starting capture process...');
      
      let captureParams;
      try {
        logMsg('Requesting capture params...');
        captureParams = await window.captureAPI.getCaptureParams();
        logMsg('Received params', { hasParams: !!captureParams, sourceId: captureParams?.sourceId });
      } catch (error) {
        logMsg('Failed to get params', { error: error.message || String(error) });
        if (window.captureAPI) {
          window.captureAPI.sendResult({ 
            success: false, 
            error: `Failed to get capture params: ${error.message || error}` 
          });
        }
        return;
      }
      
      const { sourceId, displayWidth, displayHeight, scaleFactor, cropX, cropY, cropWidth, cropHeight } = captureParams;
      
      try {
        logMsg('Requesting getUserMedia', { sourceId, hasMediaDevices: !!navigator.mediaDevices });
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: false,
          video: {
            mandatory: {
              chromeMediaSource: 'desktop',
              chromeMediaSourceId: sourceId
            }
          } as any
        } as MediaStreamConstraints);
        
        logMsg('getUserMedia succeeded', { hasStream: !!stream });

        const video = document.createElement('video');
        video.srcObject = stream;
        video.autoplay = true;
        video.playsInline = true;

        await new Promise((resolve, reject) => {
          logMsg('Setting up video load promise');
          video.onloadedmetadata = () => {
            logMsg('Video metadata loaded', { width: video.videoWidth, height: video.videoHeight });
            video.play();
            setTimeout(() => {
              logMsg('Checking video readyState', { readyState: video.readyState });
              if (video.readyState >= 2) {
                resolve(null);
              } else {
                reject(new Error('Video not ready'));
              }
            }, 300);
          };
          video.onerror = (e) => {
            logMsg('Video error', { error: String(e) });
            reject(new Error('Video playback error'));
          };
          setTimeout(() => {
            logMsg('Video load timeout');
            reject(new Error('Video load timeout'));
          }, 5000);
        });
        
        logMsg('Video ready, drawing to canvas...');

        const canvas = document.getElementById('canvas');
        canvas.width = displayWidth * scaleFactor;
        canvas.height = displayHeight * scaleFactor;
        const ctx = canvas.getContext('2d');
        
        // Draw video frame to canvas at device pixel resolution
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        logMsg('Video drawn to canvas', { width: canvas.width, height: canvas.height });

        // Stop the stream
        stream.getTracks().forEach(track => track.stop());

        // Crop the canvas
        const croppedCanvas = document.createElement('canvas');
        croppedCanvas.width = cropWidth;
        croppedCanvas.height = cropHeight;
        const croppedCtx = croppedCanvas.getContext('2d');
        croppedCtx.drawImage(canvas, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);
        logMsg('Canvas cropped', { width: cropWidth, height: cropHeight });

        // Convert to data URL
        logMsg('Converting to data URL...');
        const dataUrl = croppedCanvas.toDataURL('image/png');
        logMsg('Data URL created', { length: dataUrl.length });
        
        window.captureAPI.sendResult({ success: true, dataUrl });
        logMsg('Result sent successfully');
      } catch (error) {
        logMsg('Capture error', { error: error.message || String(error) });
        if (window.captureAPI) {
          window.captureAPI.sendResult({ 
            success: false, 
            error: error.message || 'Capture failed' 
          });
        }
      }
    } catch (initError) {
      logMsg('Initialization error', { error: initError.message || String(initError) });
      if (window.captureAPI) {
        window.captureAPI.sendResult({ 
          success: false, 
          error: `Initialization failed: ${initError.message || initError}` 
        });
      }
    }
    })();
  </script>
</body>
</html>

